<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
            Promise: ES6中新增加的类(new Promise)
            目的：为了管理JS中的异步编程，所以我们也把它称为“Promise设计模式”,让异步编程变成同步编程

            let p = new Promise();
            p.then();

            new Promise().then();
        */

        //=> pending(准备：初始化成功，开始执行异步的任务）/fulfiled(成功)/rejected(失败)
        // new Promise(()=>{
        //     //=>执行一个异步的任务(new Promise的时候，创建Promise的一个实例，立即会把当前函数体中的异步操作执行)
        //     // Promise本身是同步的，但它可以管理异步操作
        //     setTimeout(()=>{

        //     },1000);
        //     console.log(1); //先输出1
        // }).then();
        // console.log(2); //再输出2


        new Promise((resolve,reject)=>{
            //=>resolve: 当异步操作执行成功，执行resolve方法
            //=>relect: 当异步操作执行失败，执行relect方法
            setTimeout(()=>{
                resolve(100);
            },1000);
        }).then((res)=>{
            //第一个传递的函数：resolve
            console.log('ok',res); //1s后输出ok 100
        },()=>{
            //第一个传递的函数：relect
            console.log('no');
        });

        // // ajax获取数据
        // let val = null;
        // let xhr = new XMLHttpRequest();
        // xhr.open('get','1.js',true);
        // xhr.onreadystatechange = ()=>{
        //     if(xhr.readyState === 4 && xhr.status === 200){
        //         val = xhr.responseText;
        //         //=> 此时是获取结果，获取结果后还要做很多事情（此时我们只能把数据绑定等任务写在这里）

        //     };
        // };
        // xhr.send(null);
        // console.log(val); // 如果使用异步ajax请求，不等ajax彻底完成，就把val输出，此时结果是null

        // // 基于promise ajax获取数据
        // let pro = new Promise((resolve, rejected) => {
        //     //=> 执行异步操作
        //     let xhr = new XMLHttpRequest();
        //     xhr.open('get', '1.js', true);
        //     xhr.onreadystatechange = () => {
        //         if (xhr.readyState === 4 && xhr.status === 200) {
        //             val = xhr.responseText;
        //             resolve(val);
        //         }
        //         if(xhr.status !== 200){
        //             rejected();
        //         }
        //     };
        //     xhr.send(null);
        // });
        // pro.then((res)=>{
        //     console.log(res);
        //     //=> 数据绑定
        //     return 100; // 返回的结果传递给第二个then了
        // },()=>{
        //    console.log('no')
        // }).then((res)=>{
        //     // 当第一个then中的函数执行完，会执行第二个then
        //     console.log(res); // 100
        // },()=>{

        // }).then(()=>{
        //     // 当第二个then中的函数执行完，会执行第三个then
        // },()=>{
            
        // })

    </script>
</body>

</html>